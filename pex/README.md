1. Describe how your exchange works.
My exchange works through the use of interprocess communication to satisfy the requirements of the entire system. This is done by first reading the file for the products that are to be traded making an array to store the valid products that the trader can send for buy and sell orders. After this is completed, I fork my current process to create child processes for each individual trader, where I then utilise execl to create a trader process as a child of the exchange process. Once this is complete, I utilise mkfifo to create pipes between the trader and exchange and also open them, to allow for information to be sent from one to another, with signals to notify information has been sent. Once this is complete, I do the relevant calculations for buy orders and sell orders, making sure to update the pricing of each product as well as maintaining a record of the number of orders. For all these orders, I also maintain a record of the number of different orders and their buy_levels and sell_levels to make sure calculations are corredt. Once the trader disconnects, I utilise SIGCHLD to detect for this and end the program accordingly, making sure all pipes are closed and unlinked once the program finishes.

2. Describe your design decisions for the trader and how it's fault-tolerant.
My trader is able to be fault_tolerant simply due to the error checking that occurs. This includes the use of error checking for the number of arguments that are passed into the trader, where if it is < 2, the program will not run due to an insufficient amount of data. Other design decisions for the trader includes the use of error checking in terms of opening the pipe between the trader and exchange, where if an issue occurs, a perror will be raised in order to indicate such an error and the program will stop running. Another method to make sure the trader haws no issues include the use of error checking for reading from the pipe, where if the read message returns -1, it will indicate an issue in the message read from the pipe that is connected to the excahnge. Additionally, if there exists no more messages and the end has been reached, I check if it is the end of tile, printing the relevant error message across. Due to these design decisions, I am able to create a fault-tolerant trader that ensures that relevant errors can be handled

3. Describe your tests and how to run them.
I have created unit_tests under the cmocka standard to check whether my pipes are created correctly as well as if the structs created work correctly in storing the number of orders that exist. This is run via the unit_tests file and can be used to check if all the pipes are opened correctly as well as the sending and receiving of messages from them. In doing so, I was able to check if the outputs are correct using assertequals and the functions provided by cmocka to check expected output with actual output. This allowed me to perform both black box testing as well as white box testing.